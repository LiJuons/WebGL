<!DOCTYPE html>

<html>

<head>
    <title>Laiptai su Tureklais</title>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="libs/stats.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <script type="text/javascript" src="libs/OrbitControls.js"></script>
    <style>
        body{
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    $(function () {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);

        var camcontrols = new THREE.OrbitControls( camera );
        camera.position.set( 0, 20, 40 );
        camcontrols.update();

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColorHex(0xEEEEEE, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(60,20);
        var planeMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff});
        var plane = new THREE.Mesh(planeGeometry,planeMaterial);
        plane.receiveShadow  = true;

        // rotate and position the plane
        plane.rotation.x=-0.5*Math.PI;
        plane.position.x=15
        plane.position.y=0
        plane.position.z=0

        // add the plane to the scene
        scene.add(plane);

        // create a cube (step)
        var cubeGeometry = new THREE.CubeGeometry(3,1,8);
        var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});

        var step = new THREE.Mesh(cubeGeometry, cubeMaterial);
        step.castShadow = true;

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //TUUUUUUUUUUUUUUUUUUUUUUUUUUBEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        //create tube
        var spGroup;
        var tubeMesh;
        var numberOfPoints = 5;
        var points = [];
        var spoints = [];
        var rx = -1;
        var ry = 5;
        var rz = 7;
        var anglev = 0;

        for (i=0; i<36; i++){
          rx += Math.cos(anglev);
          ry += 0.5;
          rz += Math.sin(-anglev);
          points.push(new THREE.Vector3(rx,ry,rz));
          anglev += Math.PI/180 * 8;
        }


        var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), 20, 0.21, 8, false);
        var tubeMaterial = new THREE.MeshLambertMaterial({color: 0xffff00, transparent: false});
        var rail = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(rail);
        rail.castShadow = true;

        //addSpindle(18);

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //TUUUUUUUUUUUUUUUUUUUUUUUUUUBEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        //SET INITIAL VALUES
        var NUMBER_OF_STEPS = 16;
        var angle = 0;
        var sangle = 0;
        var angleNew = 18;

        var stop = 0;

        var x = 0;
        var y = 0.5;
        var z = 3;
        var sx = 0;
        var sy = 1;
        var sz = 7;

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight( 0xffffff );
        spotLight.position.set( -40, 60, -10 );
        spotLight.castShadow = true;
        scene.add( spotLight );

        // add the output of the renderer to the html element
        $("#WebGL-output").append(renderer.domElement);

        var controls = new function() {
            this.STEPS_NUM = 16;
            this.ANGLE = 18;
        }

        var gui = new dat.GUI();
        gui.add(controls, 'STEPS_NUM',1,30);
        gui.add(controls, 'ANGLE',0,45);

        render();

        function render() {

            if (Math.round(controls.STEPS_NUM) != NUMBER_OF_STEPS || Math.round(controls.ANGLE) != angleNew) {
              NUMBER_OF_STEPS = Math.round(controls.STEPS_NUM);
              angleNew = Math.round(controls.ANGLE);

              //Clear scene
              while(scene.children.length > 3){
                  scene.remove(scene.children[3]);
              }

              //RESET VALUES
              stop = 0;
              angle = 0;
              sangle = 0;

              x = 0;
              y = 0.5;
              z = 3;
              sx = 0;
              sy = 1;
              sz = 7;
            }

            if (stop != 1)
              for(i=0; i<NUMBER_OF_STEPS; i++){
                addStep(x,y,z, angle);
                addSpindle(sx,sy,sz, angle);

                //step parameters
                angle += Math.PI/180 * angleNew;
                x+=Math.cos(angle);
                y+=1;
                z+=Math.sin(-angle);

                //spindle parameters
                sangle += Math.PI/180 * (angleNew);
                sx+=Math.cos(sangle/2);
                sy+=1;
                sz+=Math.sin(-sangle/2);

                stop = 1;
              };

            requestAnimationFrame(render);
            camcontrols.update();
            renderer.render(scene, camera);
        }


        function addStep(x,y,z, angle) {
          var newStep= step.clone();
          // position the step
          newStep.position.x=x;
          newStep.position.y=y;
          newStep.position.z=z;

          newStep.rotation.y+=angle;

          // add the step to the scene
          scene.add(newStep);
        }

        function addSpindle(x,y,z, angle) {
          // var x=0;
          // var y=1;
          // var z=7;

          //for(i=0; i<count; i++){
            spoints = [];
            spoints.push(new THREE.Vector3(x,y,z));
            spoints.push(new THREE.Vector3(x,y+5,z));
            var spindleGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(spoints), 20, 0.21, 8, false);
            var spindle = new THREE.Mesh(spindleGeometry, tubeMaterial);
            spindle.rotation.y+=angle*0.6;
            scene.add(spindle);
            spindle.castShadow = true;
          //}
          // spoints.push(new THREE.Vector3(0,1,7));
          // spoints.push(new THREE.Vector3(0,2,7.5));
          // spoints.push(new THREE.Vector3(0,5,7.5));
          // spoints.push(new THREE.Vector3(0,6,7));
        }
    });

    function onDocumentMouseMove( event ) {

          event.preventDefault();

          if ( isMouseDown ) {

              theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 )
                      + onMouseDownTheta;
              phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 )
                    + onMouseDownPhi;

              phi = Math.min( 180, Math.max( 0, phi ) );

              camera.position.x = radious * Math.sin( theta * Math.PI / 360 )
                                  * Math.cos( phi * Math.PI / 360 );
              camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
              camera.position.z = radious * Math.cos( theta * Math.PI / 360 )
                                  * Math.cos( phi * Math.PI / 360 );
              camera.updateMatrix();

          }

          mouse3D = projector.unprojectVector(
              new THREE.Vector3(
                  ( event.clientX / renderer.domElement.width ) * 2 - 1,
                  - ( event.clientY / renderer.domElement.height ) * 2 + 1,
                  0.5
                  ),
              camera
          );
          ray.direction = mouse3D.subSelf( camera.position ).normalize();

          interact();
          render();

      }

</script>
</body>
</html>
